LIMS-S2
=======

Overview
--------
The Sanger *LIMS* project is a web-based Laboratory Information Management System composed of applications and modules written mainly in *Ruby* and *JavaScript*. The front end are *Javascript*  application accessing one (or more) *Ruby* server.

*S2* refers to the main server application and its components. This document is about *S2* (and *S2* only).
Those components (*Ruby gem*) are the building block of *LIMS* and are reused in different application.

All the code is open source and can be found on [*Github*](http://github.com/sanger) under the *Sanger* organization.

### Components
*S2* is decomposed of 3 gems:

+ `lims-core` : [github](http/github.com/sanger/lims-core)
Database access and general classes/modules.

+ `lims-api` : [github](http/github.com/sanger/lims-api)
Web API related , Web server JSON encoders/decoders.
Depends on `lims-core`

+ `lims-laboratory` : [github](http/github.com/sanger/lims-laboratory)
Business domain: Plate, Order etc ...
Depends on `lims-core` and `lims-api`.

### Dependencies
*S2* is based on the following gems:

+ `Virtus`  : allows attributes definitions
+ `Sequel` : access to the database.
+ `Aequitas` : Validation of `Virtus` object.
+ `Sinatra` : for the web server side.

*Virtus* and *Aequitas* comes from *datamapper2*. When the project started *datamapper2* wasn't finished it yet, which why *S2* is including is own ORM. *datamapper2* has evolved since, but introduce some incompatibilities in especially in the *Virtus*-*Aequitas* bridge making any update difficult. In the future it would be nice to either migrate to the new version of *datamapper2*, or remove the dependencies.

Design and General Concepts
---------------
### Resource and Persistence
#### Data Mapper Pattern
*S2* implements its own *ORM* using a *Data Mapper* pattern. The main idea is to decouple totally the business domain from the notion of persistence. Any class of the business domain can work on memory without the need or knowledge of a concept of persistence.
By this, we mean that  things like `plate.load`, `plate.save` or `Plate.create` and even `plate.id` don't make sense in *S2*.
A persistence layer is added on top of it, which is in charge of storing/retrieving a set of objects to/from a specific store. 

Isolating the business domain from the persistence as many benefits. The first is it simplifies the business domain implementation which can focus on implementing the business loginc in a **ideal word** without having to worry about how objects are persisted. This makes also testing easier, as one can test the business logic without having to setup a persistence context.
There is no direct link between classes and tables. Some tables needed to save an object might not have a corresponding class equivalent in the business domain. There is then no need to **expose** them in the business domain.

For example, the relation between a tube and an aliquot uses an extra *association* table : `tube_aliquots`.
+ A `Tube` represents a physical tube (a labware piece), so it deserve its own class in Business Domain.
+ An `Aliquot` represents the portion of homogeneous content within a container. Example, mixing a blood sample from A and another from blood sample B will
result in a tube containing 2 aliquots : "Blood from A" and "Blood from B", even though in practice we have no way of separating those two samples.
Even though this concept is more abstract than a tube it still has place in the Business Domain.
+ However, `TubeAliquot` which could be the class corresponding to `tube_aliquots` table doesn't exist in the Business Domain. Using the *Data Mapper* pattern we don't need (and don't have) this association class and model
`Tube` has an array of `Aliquot`.

Another benefit is it should allow to change the underlying schema or the  storage type without having to modify the Business Domain.
Let's go back to our previous example. In fact, an aliquot can only be in one tube at the same time so we don't need this extra `tube_aliquots` table. 
We could have just an `tube_id` in the `aliquots` table. We can change this without having to modify anything in the `Tube` or `Aliquot` class. We just need to change the mapping.

For information, an aliquot can belong to something else that a tube , which is why we don't have a `tube_id` in the `aliquots` table.

Another advantage of **persistence-less** Business Domain is it allows **in-memory** object creation which can be used for simulation or optimisation.
For example we can imagine an application which try to optimize some plate layout and need to create plate in memory to do so. With a standard *Active Record* pattern
it might be hard to do so, as there is no guaranty that some methods involved have no side-effect or doesn't access the database.

#### Resources (Virtus)
In order to be **mapped** easily, objects needs a common interface to be converted to and from a Hash, which is the purpose of the `Lims::Core::Resource` mixin.
A resource is an object which can be stored/retrieved in a store and encoded into JSON.
Resources uses `Virtus` to facilitate this conversion between object an Hash.
`Virtus` allows us to describe the attributes of a class and convert it automaticaly to from a hash through `initialize` and `attributes`.

For example, a *sample* is *S2* has a name. The `Sample` class is defined as follow :


`
class Sample
	include Lims::Core::Resource # a sample is a resource
  attribute :name, String # and has a name.
end
`

You can then create a new sample from Hash :
`
sample = Sample.new(:name => 'sample 1')
`
access its' name
`
puts sample.name # => 'sample 1'
`
convert it to an hash :
`
puts sample.attributes # =>  {:name => 'sample 1' }
`

In practice, `Virtus#attributes` is slow, so to speed it up, we redifine the attributes method as follow.
`
def attributes
	{:name => @name }
end
`
The problem of this approach is, it needs to be updated when a new attribute is added and it's bypassing the default value mecanism. Default value in *Virtus* are not set at initialization but the first time an accessor is called. Which is why bypassing the accessor and using `@name` is faster.












However, 
##### Optimisation

### Session => auto bulk load
##### Stores
Session 
Persistor




Project Organisation
---------------------
History
--------
### Lims-Core
### Lims-Api
### Lims-Laboratory
### Other 


### Github branches
