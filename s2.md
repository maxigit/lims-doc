LIMS-S2
=======

Overview
--------
The Sanger *LIMS* project is a web-based Laboratory Information Management System composed of applications and modules written mainly in *Ruby* and *JavaScript*. The front end are *Javascript*  application accessing one (or more) *Ruby* server.

*S2* refers to the main server application and its components. This document is about *S2* (and *S2* only).
Those components (*Ruby gem*) are the building block of *LIMS* and are reused in different application.

All the code is open source and can be found on [*Github*](http://github.com/sanger) under the *Sanger* organization.

### Components
*S2* is decomposed of 3 gems:

+ `lims-core` : [github](http/github.com/sanger/lims-core)
Database access and general classes/modules.

+ `lims-api` : [github](http/github.com/sanger/lims-api)
Web API related , Web server JSON encoders/decoders.
Depends on `lims-core`

+ `lims-laboratory` : [github](http/github.com/sanger/lims-laboratory)
Business domain: Plate, Order etc ...
Depends on `lims-core` and `lims-api`.

### Dependencies
*S2* is based on the following gems:

+ `Virtus`  : allows attributes definitions
+ `Sequel` : access to the database.
+ `Aequitas` : Validation of `Virtus` object.
+ `Sinatra` : for the web server side.

*Virtus* and *Aequitas* comes from *datamapper2*. When the project started *datamapper2* wasn't finished it yet, which why *S2* is including is own ORM. *datamapper2* has evolved since, but introduce some incompatibilities in especially in the *Virtus*-*Aequitas* bridge making any update difficult. In the future it would be nice to either migrate to the new version of *datamapper2*, or remove the dependencies.

Design and General Concepts
---------------
### Resources and Persistence
#### Data Mapper Pattern
*S2* implements its own *ORM* using a *Data Mapper* pattern. The main idea is to decouple totally the business domain from the notion of persistence. Any class of the business domain can work on memory without the need or knowledge of a concept of persistence.
By this, we mean that  things like `plate.load`, `plate.save` or `Plate.create` and even `plate.id` don't make sense in *S2*.
A persistence layer is added on top of it, which is in charge of storing/retrieving a set of objects to/from a specific store. 

Isolating the business domain from the persistence as many benefits. The first is it simplifies the business domain implementation which can focus on implementing the business loginc in a **ideal word** without having to worry about how objects are persisted. This makes also testing easier, as one can test the business logic without having to setup a persistence context.
There is no direct link between classes and tables. Some tables needed to save an object might not have a corresponding class equivalent in the business domain. There is then no need to **expose** them in the business domain.

For example, the relation between a tube and an aliquot uses an extra *association* table : `tube_aliquots`.
+ A `Tube` represents a physical tube (a labware piece), so it deserve its own class in Business Domain.
+ An `Aliquot` represents the portion of homogeneous content within a container. Example, mixing a blood sample from A and another from blood sample B will
result in a tube containing 2 aliquots : "Blood from A" and "Blood from B", even though in practice we have no way of separating those two samples.
Even though this concept is more abstract than a tube it still has place in the Business Domain.
+ However, `TubeAliquot` which could be the class corresponding to `tube_aliquots` table doesn't exist in the Business Domain. Using the *Data Mapper* pattern we don't need (and don't have) this association class and model
`Tube` has an array of `Aliquot`.

Another benefit is it should allow to change the underlying schema or the  storage type without having to modify the Business Domain.
Let's go back to our previous example. In fact, an aliquot can only be in one tube at the same time so we don't need this extra `tube_aliquots` table. 
We could have just an `tube_id` in the `aliquots` table. We can change this without having to modify anything in the `Tube` or `Aliquot` class. We just need to change the mapping.

For information, an aliquot can belong to something else that a tube , which is why we don't have a `tube_id` in the `aliquots` table.

Another advantage of **persistence-less** Business Domain is it allows **in-memory** object creation which can be used for simulation or optimisation.
For example we can imagine an application which try to optimize some plate layout and need to create plate in memory to do so. With a standard *Active Record* pattern
it might be hard to do so, as there is no guaranty that some methods involved have no side-effect or doesn't access the database.

#### Resources (Virtus)
In order to be **mapped** easily, objects needs a common interface to be converted to and from a Hash, which is the purpose of the `Lims::Core::Resource` mixin.
A resource is an object which can be stored/retrieved in a store and encoded into JSON.
Resources uses `Virtus` to facilitate this conversion between object an Hash.
`Virtus` allows us to describe the attributes of a class and convert it automaticaly to from a hash through `initialize` and `attributes`.

For example, a *sample* is *S2* has a name. The `Sample` class is defined as follow :


`
class Sample
	include Lims::Core::Resource # a sample is a resource
  attribute :name, String # and has a name.
end
`

You can then create a new sample from Hash :
`
sample = Sample.new(:name => 'sample 1')
`
access its' name
`
puts sample.name # => 'sample 1'
`
convert it to an hash :
`
puts sample.attributes # =>  {:name => 'sample 1' }
`

In practice, `Virtus#attributes` is slow, so to speed it up, we redefine the attributes method as follow.
`
def attributes
	{:name => @name }
end
`
The problem of this approach is, the `attributes` method needs to be updated when a new attribute is added to the class and it's bypassing the default value mecanism. Default values in *Virtus* are not set at initialization but the first time an accessor is called (which is probably why bypassing the accessor and using `@name` is faster).

#### Session
In order to keep the business logic totally separated from the persistence, *S2* uses a `Session` mechanism which allows 'pure' business logic code to be wrapped within a session block whick will take a care
of saving/loaded the corresponding resources. On the other hand , the `Session` mechanism has also been design to prevent as much as possible (or at least make it difficult) for programmer to mix business logic and persistence.
A way to see `Session` is to see it as transaction block where every write to the database  will be executed at the end.
Another benefit of a `Session` beside isolation is that objects can be saved in bulk if needed  and the user doesn't need to worry about the order in which to save resources or saving the same object twice : at the end of a session, every object are saved once and only once and only if needed.

Here is some example of common persistence action and there equivalent in *Rails*.

Create | 
*S2*:
`
store.with_session do |session|
	session << Plate.new
end
`
`
plate = Plate.create
`
Save a new object | 
`
plate = Plate.new
store.with_session { |s| s << plate }
`
`
plate = Plate.new
plate.save
`
Load |
`
store.with_session do |session|
	puts session.plate[plate_id]
end
`
`
puts Plate.load(plate_id)
`
Update |
`
store.with_session do |session|
	plate = session.plate[plate_id]
	# Update start there
	plate[:A1] << Aliquot.new
end
`

`
plate = Plate.load(plate_id)
# Update start there
well = plate.well.create(:A1)
well.aliquot.create
plate.save
`
*Note* The update code in *S2* doesn't need to be executed within a block
and will work perferctly *in memory*.

Delete |
`
store.with_session do |session|
	plate = session.plate[plate_id]
	session.delete plate
end
`
`
Plate.delete(plate_id)
`
*Note* In *S2*, We need to load the plate before loadind it which is unnecessary.
We could implement `Session#delete_for_id` like this :`store.with_session { |s| s.state_for_id(plate_id).mark_for_deletion }`.


#####  Automatic management
Object loaded within a session are automatically **managed** and so, automatically saved if needed
`
store.with_session do |session|
	source_plate = session.plate[source_id]
	target_plate = session.plate[target_id]

	# transfer 50% of the content of source[A1] to target[B12]
	target_plate[:B12] = source_plate[:A1].take(50)
end
`
The code above transfer 50% of the content of a well from a plate to another. Both plate are modifed (the source plate **loses** 50% of its content).
Both plate will be saved without having to specify it.
Once again, once plates have been loaded, the transfer itself is **persistence-agnostic**.

Compare with a *Rails* equivalent :
`
source = Plate.load(source_id)
target = Plate.load(target_id)
target_plate[:B12] = source_plate[:A1].take(50)
source.save
target.save
`
One can argue that the previous block a code could be rewritten so the update is also **persistence-agnosict** like this :
`
def transfer(source, target)
	target_plate[:B12] = source_plate[:A1].take(50)
end

def tranfer!(source_id, target_id)
	source = Plate.load(source_id)
	target = Plate.load(target_id)
	transfer(source, target)
	source.save
	target.save
end
`
The problem with this approach is : it is `transfer` caller responsiblity to know which plates to save whereas only `transfer` knows which plates have been modified.
With *S2* we don't have this problem.

##### Resource id
id of an existing object
`
store.with_session do |session|
	plate = session.plate[plate_id]
	session.plate.id_for(plate).should == plate_id
end
`
`
	plate = Plate.load(plate_id)
	plate.id.should ==  plate_id
`
id of an new object
`
plate_id = store.with_session do |session|
	session << plate=Plate.new
	lambda { session.plate.id_for(plate) }
end.call
`
`
plate = Plate.new
plate_id = plate.save
`

*S2* version it a bit complicated. We could call `session.plate.id_for(plate)` but this will be called **before** the plate has been saved. Remember, everything is saved **after** the end of the block, therefore
we need to call `id_for` after the end of the session (when it doesn't exist anymore). A lambda capturing the session do the trick.
Please note, that this is rarely needed in real life : the only cases we need this is mainly in specs.

#table vs rails

##### object can't be moved from different session
##### excpet if the are form the same super session
##### sub session and cache

## Uuid
### Session => auto bulk load
auto bulk save

#### pass session not store
##### Stores
Session 
Persistor

dirty keys
mixin



Project Organisation
---------------------
History
--------
### Lims-Core
### Lims-Api
### Lims-Laboratory
### Other 


### Github branches
